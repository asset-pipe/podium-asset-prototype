const e=`{{lit-${String(Math.random()).slice(2)}}}`,t=`\x3c!--${e}--\x3e`,n=new RegExp(`${e}|${t}`),s="$lit$";class o{constructor(t,o){this.parts=[],this.element=o;let r=-1,a=0;const d=[],c=o=>{const l=o.content,p=document.createTreeWalker(l,133,null,!1);let u=0;for(;p.nextNode();){r++;const o=p.currentNode;if(1===o.nodeType){if(o.hasAttributes()){const i=o.attributes;let d=0;for(let t=0;t<i.length;t++)i[t].value.indexOf(e)>=0&&d++;for(;d-- >0;){const e=t.strings[a],i=x.exec(e)[2],d=i.toLowerCase()+s,c=o.getAttribute(d).split(n);this.parts.push({type:"attribute",index:r,name:i,strings:c}),o.removeAttribute(d),a+=c.length-1}}"TEMPLATE"===o.tagName&&c(o)}else if(3===o.nodeType){const t=o.data;if(t.indexOf(e)>=0){const e=o.parentNode,s=t.split(n),x=s.length-1;for(let t=0;t<x;t++)e.insertBefore(""===s[t]?i():document.createTextNode(s[t]),o),this.parts.push({type:"node",index:++r});""===s[x]?(e.insertBefore(i(),o),d.push(o)):o.data=s[x],a+=x}}else if(8===o.nodeType)if(o.data===e){const e=o.parentNode;null!==o.previousSibling&&r!==u||(r++,e.insertBefore(i(),o)),u=r,this.parts.push({type:"node",index:r}),null===o.nextSibling?o.data="":(d.push(o),r--),a++}else{let t=-1;for(;-1!==(t=o.data.indexOf(e,t+1));)this.parts.push({type:"node",index:-1})}}};c(o);for(const e of d)e.parentNode.removeChild(e)}}const r=e=>-1!==e.index,i=()=>document.createComment(""),x=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=\/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;export{o as Template,s as boundAttributeSuffix,i as createMarker,r as isTemplatePartActive,x as lastAttributeNameRegex,e as marker,n as markerRegex,t as nodeMarker};
